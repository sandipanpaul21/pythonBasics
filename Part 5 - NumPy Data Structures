# NumPy Data Structures

# one-dimensional array then represents, mathematically speaking, a vector of, in general, real numbers, internally represented by float objects. 
# It then consists of a single row or column of elements only.
# In a more common case, an array represents an i × j matrix of elements. 
# This concept generalizes to i × j × k cubes of elements in three dimensions as well as to general ndimensional arrays of shape i × j × k × l × … .

# Array with python list

v = [0.5, 0.75, 1.0, 1.5, 2.0] # vector of numbers
print(v) # [0.5, 0.75, 1.0, 1.5, 2.0]

m = [v,v,v] # matrix of numbers
print(m) # [[0.5, 0.75, 1.0, 1.5, 2.0], [0.5, 0.75, 1.0, 1.5, 2.0], [0.5, 0.75, 1.0, 1.5, 2.0]]

# select rows via simple indexing or single elements via double indexing
m[1]  # [0.5, 0.75, 1.0, 1.5, 2.0]
m[1][0]  # 0.5

v1 = [0.5, 1.5]
v2 = [1, 2]
m = [v1,v2]
m # [[0.5, 1.5], [1, 2]]
c = [m,m]  # cube of numbers
c # [[[0.5, 1.5], [1, 2]], [[0.5, 1.5], [1, 2]]]
c[1] # [[0.5, 1.5], [1, 2]]
c[1][1] # [1, 2]
c[1][1][0] # 1

v = [0.5, 0.75, 1.0, 1.5, 2.0]
m = [v,v,v]
m

#[[0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0]]

v[0] = 'python'
v # ['python', 0.75, 1.0, 1.5, 2.0]
m
#[['python', 0.75, 1.0, 1.5, 2.0],
# ['python', 0.75, 1.0, 1.5, 2.0],
# ['python', 0.75, 1.0, 1.5, 2.0]]

# Note all are changed to python, this can be avoided by using the deepcopy function of the copy module
from copy import deepcopy
v = [0.5, 0.75, 1.0, 1.5, 2.0]
v # [0.5, 0.75, 1.0, 1.5, 2.0]
m = 3 * [deepcopy(v), ]
m
#[[0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0]]
v[0] = 'Python'
v # ['python', 0.75, 1.0, 1.5, 2.0]
m
#[[0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0],
# [0.5, 0.75, 1.0, 1.5, 2.0]]

# Regular NumPy Arrays
import numpy as np
a = np.array([0, 0.5, 1.0, 1.5, 2.0])
a # array([0. , 0.5, 1. , 1.5, 2. ])
type(a) # numpy.ndarray
a[:2] # # indexing as with list objects in 1 dimension, array([0. , 0.5])

# Major feature of the numpy.ndarray class is the multitude of built-in methods
a.sum()  # sum of all elements, 5
a.std()  # standard deviation, 0.7071067811865476
a.cumsum() # running cumulative sum , array([0. , 0.5, 1.5, 3. , 5. ])

# major feature is the (vectorized) mathematical operations defined on ndarray objects
a * 2 # array([0., 1., 2., 3., 4.])
a ** 2 # array([0.  , 0.25, 1.  , 2.25, 4.  ])
np.sqrt(a) # array([0.        , 0.70710678, 1.        , 1.22474487, 1.41421356])

# indexing system is made consistent across all dimensions
b = np.array([a,a*2])
b
#array([[0. , 0.5, 1. , 1.5, 2. ],
#       [0. , 1. , 2. , 3. , 4. ]])

b[0] # first row, array([0. , 0.5, 1. , 1.5, 2. ])
b[0, 2] # third element of first row, 1.0
b.sum() # total sum, 15
b[0].sum() # first row sum, 5

# In contrast to our list object-based approach to constructing arrays, the numpy.ndarray class knows axes explicitly. 
# Selecting either rows or columns from a matrix is essentially the same:
b.sum(axis = 0) # sum along axis 0, i.e. column-wise sum, array([0. , 1.5, 3. , 4.5, 6. ])
b.sum(axis = 1) # sum along axis 1, i.e. row-wise sum, array([ 5., 10.])
